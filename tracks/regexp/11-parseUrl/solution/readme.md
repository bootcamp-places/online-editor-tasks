# parseUrl

Розв'язання цієї задачі може виглядати ось так:

```js
const parseUrl = (url = "") => {
  const urlRegex = /^(https?):\/\/([^:/]+):?(\d+)?(\/.*)?$/i;
  const [, protocol, host, port, path] = url.match(urlRegex) || [];

  return { protocol, host, port, path };
};
```

Давайте розберемо цей код.

## Регулярний вираз

Регулярний вираз, який ми використовуємо для розбору URL, виглядає так:

```js
/^(https?):\/\/([^:/]+):?(\d+)?(\/.*)?$/i;
```

Використовуємо `i` флаг, щоб зробити вираз нечутливим до регістру. Символ `^` вказує на початок рядка, а `$` - на кінець. Це дозволяє нам використовувати `^` та `$` в середині виразу. Це дуже корисно, коли ми хочемо використовувати групувальні вирази. Якщо ми не використовуємо `^` та `$`, то вираз буде відповідати будь-якому рядку, який містить вказані символи.

### Протокол

Перший групувальний вираз `(https?)` вибирає протокол. Він може бути `http` або `https`. Зверніть увагу, що ми використовуємо `?` після `s`, щоб вказати, що символ `s` може бути або присутній, або відсутній. Також `:\/\/` вказує на те, що ми очікуємо `://` після протоколу.

```js
/^(https?):\/\//i;
```

### Домен

Другий групувальний вираз `([^:/]+)` вибирає домен. Він може складатися з будь-якої кількості букв, цифр, крапок та дефісів. Ми використовуємо `+` після `[^:/]`, щоб вказати, що символи можуть повторюватися багато разів.

```js
/^(https?):\/\/([^:/]+)/i;
```

### Порт

Третій групувальний вираз `(\d+)` вибирає порт. Він може складатися з будь-якої кількості цифр. Перед номеру порту завжди передує двокрапка, а якщо її немає, то відповідний групувальний вираз поверне `undefined`, оскільки він не знайде збігів, тобто порт не вказаний.

```js
/^(https?):\/\/([^:/]+):?(\d+)/i;
```

### Шлях

Четвертий групувальний вираз `(\/.*)` вибирає шлях. Він може складатися з будь-якої кількості символів.

```js
/^(https?):\/\/([^:/]+):?(\d+)?(\/.*)?$/i;
```

## Функція `match`

Функція `match` використовується для пошуку збігів з регулярним виразом. Вона повертає масив зі збігами або `null`, якщо збігів не знайдено. В цьому випадку, якщо `match` поверне `null`, а ми спробуємо отримати доступ до елементів масиву, то це призведе до помилки. Тому ми використовуємо `|| []`, щоб виключити можливість помилки.

```js
const url = "https://shop.ua/community";
const urlRegex = /^(https?):\/\/([^:/]+):?(\d+)?(\/.*)?$/i;
const matches = url.match(urlRegex) || [];

console.log(matches);
// ["https://shop.ua/community", "https", "shop.ua", undefined, "/community"]
```

## Деструктуризація

Деструктуризація використовується для отримання значень з масиву. Вона дозволяє присвоїти значення з масиву змінним. В нашому випадку, ми використовуємо деструктуризацію для отримання значень з масиву `matches` та присвоєння їх змінним.

```js
const matches = ["https://shop.ua/community", "https", "shop.ua", undefined, "/community"];
const [, protocol, host, port, path] = matches;

console.log(protocol);
// "https"
console.log(host);
// "shop.ua"
console.log(port);
// undefined
console.log(path);
// "/community"
```

## Об'єкт

Об'єкт, який повертається функцією `parseUrl`, виглядає так:

```js
{
  protocol: "https",
  host: "shop.ua",
  port: undefined,
  path: "/community"
}
```

Зверніть увагу, що значення `port` дорівнює `undefined`, а не `null`. Це відбувається тому, що ми використовуємо `undefined` для вказання відсутності порту. Якщо порт вказаний, то він буде присвоєний змінній `port` та буде включено в об'єкт.

Також ми використовуємо скорочену форму запису властивостей об'єкта, оскільки назви властивостей та змінних співпадають.

```js
return { protocol, host, port, path };
```

що в розкладеному вигляді виглядає так:

```js
return {
  protocol: protocol,
  host: host,
  port: port,
  path: path
};
```

## Корисні посилання

- [Wikipedia: Uniform Resource Identifier](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
- [Wikipedia: Uniform Resource Locator](https://en.wikipedia.org/wiki/Uniform_Resource_Locator)
- [Wikipedia: URL encoding](https://en.wikipedia.org/wiki/Percent-encoding)
